{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2023-06-08T01:55:19.390498+00:00",
  "repo": "davidben/merkle-tree-certs",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOJIBkVc5gi33k",
      "title": "Time math is ambiguously-specified",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/1",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Leap seconds, UTC, TAI, etc., are all the worst. While we never actually write the timestamps on the wire, it is important that everyone agree, for a given batch number, what times they refer to.\r\n\r\nThe intent was that you just do math in POSIX time, since that's what every programming language gives you. But if there's ever another leap second, it gets a little tricky. It might be that we have to literally cite POSIX here? Something like: all of these are just measured in seconds, do the math in seconds to get a POSIX timestamp, convert the current time to POSIX time, and then compare in that space?\r\nhttps://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_16\r\n\r\nOtherwise you have to answer ridiculous questions like what happens at one of the POSIX timestamps that correspond to multiple times of day.\r\n\r\nNot that anything at this granularity matters _at all_ for a PKI.",
      "createdAt": "2023-03-10T23:32:00Z",
      "updatedAt": "2023-03-18T01:18:44Z",
      "closedAt": "2023-03-18T01:18:44Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Notes to self for specifying this:\r\n* C++ says that `std::chrono::system_clock` says \"time since 1970-01-01 00:00:00 UTC excluding leap seconds\"\r\n* POSIX has a DOI, so generating the citation is pretty easy.\r\n",
          "createdAt": "2023-03-15T22:15:57Z",
          "updatedAt": "2023-03-15T22:15:57Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "I_kwDOJIBkVc5gql1x",
      "title": "How long must long-expired batches be served",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/2",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "As currently written, neither CAs nor the transparency service are allowed to stop serving long-outdated batches. Should we relax this? Some nuisances:\r\n\r\n* Storage windows should be much larger than validity windows, to allow for RP clock skew\r\n* If the CA's storage window is smaller than the TS's storage window, it is possible that a transparency service will fail to log something if it's really, _really_ behind. That said, it would need to be behind by more than the CA's storage window and if that's, say, a year, that's probably fine.\r\n* A bigger issue is that if the TS spins up after the CA does, it can't bootstrap itself with data before the CA's storage window (unless it pulls it from another mirror)",
      "createdAt": "2023-03-13T15:55:05Z",
      "updatedAt": "2023-06-05T12:11:59Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "> Storage windows should be much larger than validity windows, to allow for RP clock skew\r\n\r\nFor the common case, where the roots are side-loaded to the RP, the transparency service can also side-load an approximate time. The latest batch you got is an estimate of the time!\r\n\r\n> if it's really, really behind\r\n\r\nIf a transparency service is that much behind, then it can't perform its main function: allowing clients to authenticate. (Transparency service is perhaps not the best name.)\r\n\r\nIf everything functions normally, I'd say that the CAs would really only need to store batches for another day or so. On the other hand, when things go wrong, it's nice to have some time to figure things out. We shouldn't go overboard here: it's harder for the CAs to serve a year's worth of batches, than three weeks.\r\n\r\nIndeed, the size of assertions is dominated by the size of the public keys. If they're all RSA-2048, we're looking at roughly 1.5GB per day. Serving 32GB for three weeks is much easier than 560GB. If they're all Dilithium3, then we're looking at 250GB for three weeks and 4.2TB for a year. See also #6 .\r\n\r\nI want to try making running this as easy as possible, so at the moment I'd lean towards a storage window of 4 weeks.",
          "createdAt": "2023-03-18T10:05:08Z",
          "updatedAt": "2023-06-05T12:11:59Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "> For the common case, where the roots are side-loaded to the RP, the transparency service can also side-load an approximate time. The latest batch you got is an estimate of the time!\r\n\r\nYup! Though I think we should still ponder clock skew because the RP's clock may get off after this update and then fail to take new updates.\r\n\r\nAlso I think a CA's recent history, even if the cert has since been expired, is still relevant in the limit for monitoring it. After all, transparency is inherently a post-facto thing. It takes time for a logged certificate to be observed by someone. Though, yeah, maybe we don't need a whole year's worth? I dunno. It's also really the TS's history that matters, provided the TS doesn't get too behind.\r\n\r\n> If a transparency service is that much behind, then it can't perform its main function: allowing clients to authenticate.\r\n\r\nWell, it has a few functions:\r\n* Allowing RPs to accept assertions\r\n* Providing a public view of all assertions the CA has made\r\n* Maintaining the invariant that RPs only accept assertions that have been mirrored\r\n\r\nBut you're right that a TS that's so far behind isn't doing anything. It's still meeting the primary invariant, but the system's effectively down at that point. :-)\r\n\r\nAnd perhaps a bigger point is that, support the TS is down for a bit and loses some entries because they were past the CA's storage window. If zero TS instances ever saw it, while it's unfortunate to lose a view of CA misbehavior, we know that no RP ever accepted it at any point in time, so it's not a *huge* deal.\r\n\r\n> (Transparency service is perhaps not the best name.)\r\n\r\nOriginally called it \"update service\" to kinda reflect what I expect to be the most common deployment pattern, but transparency service seemed a better generalization, especially in some of the other deployment models where it's a bunch of services together. But not attached to the name.\r\n\r\n> I want to try running this as easy as possible, so at the moment I'd lean towards a storage window of 4 weeks.\r\n\r\nYeah, I think you've convinced me that, at least for the CA, it's both useful and not particularly harmful to have a short storage window. Though the language around the TS and the HTTP interface overall would need to account for it. And we probably formally need to allow the TS to have holes in this \"TS went offline and got more than 4 weeks behind\" state.",
          "createdAt": "2023-03-19T02:40:57Z",
          "updatedAt": "2023-03-19T02:40:57Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "I_kwDOJIBkVc5g61sf",
      "title": "merkle_tree_sha256 TrustAnchors mean different things in different contexts",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/3",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "In the context of a BikeshedCertificate, (issuer, 1000) means this certificate is part of batch 1000 in the specified CA.\r\n\r\nIn the context of trust anchor negotiation (the RP's trust anchor list, the list of aliases), it refers to a whole window. That is, if window_size is 100, sending (issuer, 1000) means you are advertising (issuer, 901) through (issuer, 1000).\r\n\r\nThis works out, but it's a little weird. Maybe we should just allocate two different ProofType codepoints, with the second one referring to the whole window?",
      "createdAt": "2023-03-15T18:21:16Z",
      "updatedAt": "2023-03-31T11:54:56Z",
      "closedAt": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "I've also started informally saying \"aliases\" now but the draft says \"additional trust anchors\". Also something to fix as we refine the negotiation story.",
          "createdAt": "2023-03-30T23:02:52Z",
          "updatedAt": "2023-03-30T23:02:52Z"
        },
        {
          "author": "nharper",
          "authorAssociation": "NONE",
          "body": "It seems that the TrustAnchor struct is used in 3 distinct places (in the BikeshedCertificate, in the RP's store identifying which certs it accepts, and sent in the TrustAnchors TLS extension). This would be clearer if at least the last use case is separated out. In the BikeshedCertificate, the TrustAnchor appears to be the correct structure. In the RP's store, a list of TrustAnchors can be simplified to an issuer_id and a range of batch_numbers (though this is an implementation detail). When negotiating the use of Merkle Tree certificates, the RP needs to communicate a list of (issuer_id, batch_number range), which can be optimized as a list of (issuer_id, latest batch_number). While (issuer_id, latest batch_number) has the same format as a TrustAnchor, is is semantically different and could be improved upon in the spec by calling it something else.",
          "createdAt": "2023-03-30T23:58:33Z",
          "updatedAt": "2023-03-30T23:58:33Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Yeah, I think that'd make sense. I think, when I'd originally written it, I was thinking:\r\n\r\n- RPs advertising (issuer_id, 1000) means they support (issuer_id, 1000), which is a true statement\r\n- If an RP supports 1000, it also supports 900..1000. (Or you can think of it as supporting 0..1000 and then throwing out all the expired ones.)\r\n- The subscriber/CA know this fact and so, they'll accept larger batch numbers in lieu of their current one, up to window size\r\n- RPs know that subscriber/CA knows this, so they choose not to advertise the other 99 values they also support, because you're not obligated to list everything you support, only to support everything you list.\r\n\r\nBut this is pretty confusing, so it probably makes sense to explicitly treat these as aliases.",
          "createdAt": "2023-03-31T11:50:11Z",
          "updatedAt": "2023-03-31T11:51:33Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Really all this is an artifact of me, at the very last minute, switching from begrudgingly conceding that the subscriber has to know something about the structure of `merkle_tree_sha256` TrustAnchors (this 1000 implies 900..1000 property) to, at the least minute, realizing you can model this with the CA handling you a pile of aliases and then scribbling that in without thinking about it too hard! :-D\r\n\r\nBut it's pretty annoying that the CA has to list out hundreds of aliases, so maybe we actually should have some notion of versioned things in the generic structure anyway...",
          "createdAt": "2023-03-31T11:54:34Z",
          "updatedAt": "2023-03-31T11:54:56Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDOJIBkVc5hJ4Q1",
      "title": "Clarify that unparsable signing inputs are still misissuance",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/5",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "We currently say:\r\n\r\n> If the CA's private key signs an input that can be interpreted as a LabeledWindow structure, the CA is considered to have certified every assertion contained in every value in the `tree_heads` list, with expiry determined by `batch_number`, the position of the tree head in the list, and the CA's input parameters as described in {{parameters}}.\r\n\r\nBut this leaves open what if the CA's private key signs an input that can't be parsed. Buggy parsers in the RP are bad, but they shouldn't be instant security bugs. To fix that, we should say:\r\n\r\n* If the CA's private key signs *any* input beginning with `Merkle Tree Certificate Window\\0`, it is in scope for this document. If it cannot be parsed as a LabeledWindow, or if the hashes were invalid, this is misissuance.\r\n* Signing other labels is, a priori, also misissuance, though future protocol extensions MAY define other label prefixes that do have meaning. I.e., if we want to have the CA sign other messages with the same key, we may define a different label for it, but the CA shouldn't be allowed to just randomly sign stuff that seems like fun.",
      "createdAt": "2023-03-17T22:15:47Z",
      "updatedAt": "2023-06-05T17:26:21Z",
      "closedAt": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "It's implied, but we should probably also spell it out explicitly: it doesn't matter if the CA ever served the signature over the HTTP interface. If it generated such a signature, it issued it and is responsible for whatever it signed.",
          "createdAt": "2023-03-20T15:51:13Z",
          "updatedAt": "2023-03-20T15:51:13Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "There is another case: if a signature is served, which itself does not verify, then we should not count it as a misissuance. The signature would not be trusted anyway (as it doesn't verify), and this gives some robustness against some bitflips. #26 ",
          "createdAt": "2023-06-05T10:41:12Z",
          "updatedAt": "2023-06-05T10:41:12Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Oh yeah, there's \"I cannot parse the signature\" and \"you signed a thing that does not parse but has the right context string\". I meant the latter. I'll go rename the issue to be clearer.\r\n\r\nAgreed that if the signature doesn't verify, it's not misissuance. The system has misbehaved, but I think that can be thought of as a generalized outage. Specifically, it doesn't cause a durable security problem the way having a bad signature in the world does.",
          "createdAt": "2023-06-05T17:26:00Z",
          "updatedAt": "2023-06-05T17:26:00Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "I_kwDOJIBkVc5hK-07",
      "title": "Should we include or only bind public keys in assertions",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/6",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The size of assertions is dominated by the public key. Classical public keys are small: ~32/64 bytes for ECC, ~256/512 bytes for RSA. Post-quantum public keys are larger. 1312/1953B for Dilithium2/3, 897B for Falcon512. There are also some unbalanced (smaller sigs, but larger public keys) schemes on the horizon with even larger public keys: 5kB for Mayo_2, \u2265500kB for UOV.\r\n\r\nInstead of storing the public key in the assertion, we could store `H(public key)` [1]. The relying party would still need to send the public key. We could include it in the bikeshed certificate.\r\n\r\nThe downsides are:\r\n\r\n1. It slightly complicates the protocol.\r\n2. We send 32 bytes extra in the TLS connection.\r\n3. We can't check for weak public keys.\r\n\r\n[1] We might actually want to do `H(domain sep || public key || claim_type || claims)`",
      "createdAt": "2023-03-18T10:31:31Z",
      "updatedAt": "2023-06-05T11:49:19Z",
      "closedAt": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "We don't necessarily need to send 32 bytes extra in TLS. It's a little gross, but the RP could reconstruct the assertion with the hashed value. (Arguably it's better to make them do that, so they don't accidentally forgot to check H(pubkey) matches.)\r\n\r\nI kept thinking this would impede transparency somewhat, but I think that's just faulty intuition. If you know the set of expected pubkeys, you can check for an unexpected hash just as easily as an unexpected pubkey. And if you don't know the set, it's not like the unhashed pubkey is any more checkable (point 3 aside) than the hashed one.\r\n\r\nAnd yeah if serving obligations are a problem for CAs and TSs, a 30x size decrease sounds like a good way to clear it! :-) Though we'd have to be crystal clear that *any* unexpected pubkey hash counts as an unauthorized certificate, of equal severity, whether monitors can produce a preimage or not. That is, a CA can't say \"that's weird, but it's not a security issue because we promise no pubkey hashes to it\".  (Relatedly, #5.)\r\n\r\nAnother oddity: I think CAs typically check proof of possession of the private key, so they would need to see the preimage during issuance. We also expect CAs to have audit logs of everything they do. I think those together mean the CA must *store* the private key one way or another. If so, this would only offset serving costs, rather than storage costs. And if the CA's required to store it, they probably should still be able to produce it on demand, but I suppose that needn't necessarily be served online / mirrored by everyone.\r\n\r\n@devonobrien for thoughts on this.",
          "createdAt": "2023-03-20T15:28:35Z",
          "updatedAt": "2023-03-20T15:28:35Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "> It's a little gross, but the RP could reconstruct the assertion with the hashed value.\r\n\r\nOh, yes, of course :facepalm:, that's the obvious thing to do.\r\n\r\n>  any unexpected pubkey hash counts as an unauthorized certificate\r\n\r\nYes, definitely. (You could see this as a transformation of the underlying signature scheme: we're changing pk into H(pk) and sig into pk || sig.)\r\n\r\n> If so, this would only offset serving costs, rather than storage costs.\r\n\r\nAside from material cost, there is also the effort of keeping it running under stress or recovering from issues: it's easier to quickly fix something in a 100GB database, than a 3TB database.",
          "createdAt": "2023-03-21T10:29:32Z",
          "updatedAt": "2023-03-21T10:29:32Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "> It's a little gross, but the RP could reconstruct the assertion with the hashed value.\r\n\r\nWe should include the hash because otherwise the TS can't generate the Merkle tree.",
          "createdAt": "2023-03-31T23:38:37Z",
          "updatedAt": "2023-03-31T23:38:50Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Oh yeah the CA-to-TS format definitely needs to include the hash. And I suppose that's the main nuisance here. The ideal format from CA to TS and subscriber to RP now differ and we need to keep them all straight, or pay some costs.",
          "createdAt": "2023-04-01T01:28:38Z",
          "updatedAt": "2023-04-01T01:28:38Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "We can't leave out the hash from the assertion as served by the CA to the TS, but we could leave out the hash from the. BikeshedCertificate. That would complicate its definition a bit: we'd need two different Assertion structs.",
          "createdAt": "2023-06-05T11:49:19Z",
          "updatedAt": "2023-06-05T11:49:19Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDOJIBkVc5hOLvI",
      "title": "Should TLS CertificateType incorporate SubjectType?",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/7",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Right now we have one TLS CertificateType value, `bikeshed`, for all of BikeshedCertificate. This is good for treating ProofType opaquely, but it also negotiates all SubjectTypes at once.\r\n\r\nThe SubjectType for TLS is implicitly `tls`, so that works out. But suppose we needed to define something like. If we build a TLS out of a different key type (e.g. KEMTLS), it'll want a different SubjectType. Or maybe we just decide we need to define `tls2` for some reason.\r\n\r\nSomething like KEMTLS might its own negotiation story anyway, so this may be fine. Something like `tls2` would need its own signaling extension. Perhaps we should just rename it to `bikeshed_tls` which is BikeshedCertificate + SubjectType = tls. And then other SubjectTypes intended for use with TLS just get their own corresponding CertificateType values.",
      "createdAt": "2023-03-19T20:35:49Z",
      "updatedAt": "2023-03-19T20:36:06Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 8,
      "id": "I_kwDOJIBkVc5hTEdD",
      "title": "Should the RP advertise TrustAnchor exclusions on top of TrustAnchor sets?",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/8",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "https://github.com/davidben/merkle-tree-certs/issues/3 discusses how the negotiation scheme really believes in sets of TrustAnchors. That is, the BikeshedCertificate is identified by a TrustAnchor, say (issuer, 950), but the RP sends a single value that means (issuer, 901..1000).\r\n\r\nSuppose some batch, (issuer, 975) went wrong. Because our sets have fixed width, we have to wait for the certificate lifetime to pass (i.e. the bad batch falls off the validity window) before RPs can accept anything from the CA again. Because even if the TS can tell the RP \"trust (issuer, 901...1000) but skip (issuer, 975)\", the RP can't tell the subscriber this. Over-advertising in the ClientHello risks the subscriber picking the bad batch.\r\n\r\nTwo answers for this:\r\n* Just advertise it anyway. The CA knows it messed up, so it's the CA's responsibility to get all the subscribers to renew and dump the old proof (e.g. with ACME ARI)\r\n* We have some way to list exclusions\r\n\r\nThe second could be interesting. What if we could send an exclusion list somehow? Either an explicit list of TrustAnchors, or some sort of hashing scheme. Structures, like CRLlite's Bloom filter cascade or perfect hashing describe a subset of a finite universe of inputs. If we can make that compact enough, that might be useful...\r\n\r\nIn particular, in a more traditional PKI mechanism, that would allow RPs to advertise supersets like \"CCADB/2023-03-20\" and then exclude the entries in there they don't trust.\r\n\r\nAlso, consider a distrust. Let's say I currently trust \"roots-v1\" which contains a bunch of CAs, {CA1, CA2, CA3, ...}, but now I need to distrust CA1. I can mint \"roots-v2\", but until the subscribers all get new alias lists from ACME, they won't understand it. The existing subscribers on CA2, CA3, etc., only know about \"roots-v1\". But if I advertise \"roots-v1\", the existing subscribers on CA1 will mistakenly believe their proof is still okay.",
      "createdAt": "2023-03-20T15:46:46Z",
      "updatedAt": "2023-03-21T22:59:22Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "> Two answers for this\r\n\r\nLet me add a few other options:\r\n\r\n1. When the browser sees a proof from the bad batch, it retries the handshake excluding the CA or with Merkle Certs disabled.\r\n2. We completely distrust the CA that screwed up. The CA can then get a new CA id and mint new certs.\r\n\r\nYou are discussing two different exclusions: excluding CAs from a set and excluding batches from a CA. I think the former is more worthwhile than the latter. Hopefully it's rare that we need to exclude single batches. It'll be much more common that someone wants to exclude a CA completely from a set.",
          "createdAt": "2023-03-21T14:58:55Z",
          "updatedAt": "2023-03-21T14:59:04Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "> You are discussing two different exclusions: excluding CAs from a set and excluding batches from a CA. I think the former is more worthwhile than the latter.\r\n\r\nAgreed. Yeah, I mention the batches one just because it's more immediately relevant, but I was mostly thinking about it in the context of this CA set idea. That, I supsect, fits a bit more into a signature-based ProofType (which the doc's not defining) than this Merkle Tree one.",
          "createdAt": "2023-03-21T22:59:21Z",
          "updatedAt": "2023-03-21T22:59:21Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "I_kwDOJIBkVc5hbOlT",
      "title": "Feature Request: Support for IP ranges",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/9",
      "state": "OPEN",
      "author": "bemasc",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Analogous to DNS wildcards, it would be helpful to support IP range claims like `192.0.2.0/24`.",
      "createdAt": "2023-03-21T18:54:29Z",
      "updatedAt": "2023-03-21T18:54:29Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 10,
      "id": "I_kwDOJIBkVc5hbvK1",
      "title": "Question: SubjectType, Intermediate CAs, and cross-signing",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/10",
      "state": "OPEN",
      "author": "bemasc",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "It seems like right now, there is only one SubjectType (\"tls\").  Since Intermediate CAs (ICAs) are not signing TLS keyshares, this seems to mean that ICAs are not (yet) supported.  I don't know that ICAs are important per se, but cross-signing has been an important way for new CAs to gain trust, and has the effect of making them ICAs from the point of view of pre-existing clients.\r\n\r\nIs there a plan here to support ICAs?  If so, I think it will be important to specify name constraints from the beginning.  (Adding constraints as an extension didn't work last time...)\r\n\r\nRelated brainstorm: it would be helpful to have a clear way for one CA to manage multiple independent signature streams.  That way, I can put my ICA/cross-signs into a very low-throughput stream that generates very small inclusion proofs, separate from my high-volume end-entity stream that generates larger proofs.",
      "createdAt": "2023-03-21T20:42:55Z",
      "updatedAt": "2023-03-21T23:05:58Z",
      "closedAt": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "I don't think ICAs makes sense for specifically the Merkle Tree ProofType. The Merkle Tree ProofType already presumes an updated RP. Particularly in a world of giant PQ signatures, there's no point in doing that on the Subscriber <-> RP flow. Just push the new CA to the RP.\r\n\r\nThe document doesn't define other ProofTypes, but, for unupdated RPs, one could imagine defining a signature-based ProofType that looks more like X.509. In that case, yeah, I agree delegation makes sense. (Although large signatures shift the tradeoffs between delegations vs. RP updates a bit.)\r\n\r\nBut since X.509 path-building has been a disaster, I don't think that should be done with SubjectType and chaining. Rather, the chain of delegations and signatures should be embedded into `proof_data` directly. From the perspective of the subscriber, the whole chain is an atomic unit.\r\n\r\nAnd, yeah, definitely agreed that will require working through a whole lot of details, including constraints. I... have some thoughts on this, but have not yet put them together into anything coherent, so just started with the Merkle Tree idea. \ud83d\ude04 ",
          "createdAt": "2023-03-21T22:55:14Z",
          "updatedAt": "2023-03-21T23:05:58Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "I_kwDOJIBkVc5hitCu",
      "title": "Clarify you send only one CertificateEntry in TLS",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/11",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "TLS Certificate messages technically have a whole set of them, to form a chain. We expect any chaining behavior to fit inside the `proof_data` field (see discussion in https://github.com/davidben/merkle-tree-certs/issues/10), so we should add a sentence to clarify this.",
      "createdAt": "2023-03-22T20:58:00Z",
      "updatedAt": "2023-04-04T13:30:55Z",
      "closedAt": "2023-04-04T13:30:55Z",
      "comments": []
    },
    {
      "number": 12,
      "id": "I_kwDOJIBkVc5hitIy",
      "title": "Flesh out HTTP interface",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/12",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Filing this to capture the TODO left in the doc",
      "createdAt": "2023-03-22T20:58:20Z",
      "updatedAt": "2023-06-05T12:00:07Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "> [[TODO: This section hasn't been written yet. For now, this is just an informal sketch. The real text will need to define request/response formats more precisely, with MIME types, etc. ]]\r\n\r\n> [[TODO: If we have the window endpoint, do we still need to separate \"info\" and \"assertions\"?]]\r\n\r\n",
          "createdAt": "2023-06-05T12:00:07Z",
          "updatedAt": "2023-06-05T12:00:07Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "I_kwDOJIBkVc5hitMX",
      "title": "Flesh out ACME interface",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/13",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Filing this to capture TODO in the doc",
      "createdAt": "2023-03-22T20:58:34Z",
      "updatedAt": "2023-05-26T20:21:09Z",
      "closedAt": null,
      "comments": [
        {
          "author": "aarongable",
          "authorAssociation": "NONE",
          "body": "From an absolutely minimalist perspective, ACME can do *almost* everything necessary for MTC today:\r\n- the newOrder request contains a list of identifiers\r\n- fulfilling challenges to prove domain control remains the same\r\n- the finalize request should be updated to not contain a CSR (to avoid big x509 structures and signatures in the MTC world), but otherwise works the same\r\n- finalization would take a long time (up to `batch_duration` minutes) but ACME already supports async finalization\r\n- after finalization, the order's `certificate` URL would return a (base64-encoded?) BikeshedCertificate rather than a PEM-encoded x509 Certificate\r\n\r\nThat's just two minor changes for the most basic level of support.\r\n\r\nBut, that leaves on the floor a few key questions:\r\n- How do subscribers request an MTC? Do they make their requests to a wholly different ACME server (different base directory url, etc)? Do they include some information in the newOrder or finalize request indicating that they want an MTC?\r\n- How do subscribers get both an MTC and a backup traditional certificate to use before the new batch is issued and propagated to browsers? Do they make separate newOrder requests (and potentially fulfill separate domain control challenges) for each kind? Do they make a single newOrder request which then creates multiple Order objects to be finalized separately? Does a single Order end up with multiple different certificate download links after finalization?\r\n- Imagining the future pointed at by the current draft's extensible ProofTypes, how does an ACME server indicate to the client which certificate they should present in which circumstances?\r\n\r\nI'm personally leaning towards a world where a single newOrder request can end up resulting in issuance of multiple certificates for the same pubkey+identifiers. Perhaps where the finalized Order object contains a list of both certificate download URLs and metadata about each of those certificates.",
          "createdAt": "2023-05-26T20:21:08Z",
          "updatedAt": "2023-05-26T20:21:08Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "I_kwDOJIBkVc5hveoS",
      "title": "BikeshedCertificate is a placeholder name",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/15",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Obviously we'll need to rename this at some point...",
      "createdAt": "2023-03-24T18:10:40Z",
      "updatedAt": "2023-03-24T18:10:40Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 16,
      "id": "I_kwDOJIBkVc5hvfAa",
      "title": "Editorial: Perhaps define certificate format earlier?",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/16",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Assertions are defined up in section 4, but the corresponding certificate format is buried in 5.4.3. It is a convenient place to put it chronologically in the story, but it's kinda weird to have a core type be buried in there. Maybe we should move parts of that up to be next to Assertions.",
      "createdAt": "2023-03-24T18:12:05Z",
      "updatedAt": "2023-03-26T02:45:22Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "Repetition is also an option. We could write \"later we will define a BikeshedCertificate as\".",
          "createdAt": "2023-03-26T02:45:21Z",
          "updatedAt": "2023-03-26T02:45:21Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "I_kwDOJIBkVc5hv-aW",
      "title": "Discuss clock skews",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/17",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Probably under deployment considerations. The shortlived certificate aspect assumes your clock is right. Although we also get to play on easy: we're only considering up-to-date RPs and those RPs (presumably) got a clock update in the most recent update.\r\n\r\nThe clock could have gone wrong since though, so deployments would need to ponder this.",
      "createdAt": "2023-03-24T20:03:02Z",
      "updatedAt": "2023-03-24T20:03:02Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 18,
      "id": "I_kwDOJIBkVc5hzIKX",
      "title": "Resolve client certificate type negotiation issues",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/18",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "See https://www.ietf.org/archive/id/draft-davidben-tls-merkle-tree-certs-00.html#name-certificate-type-negotiatio",
      "createdAt": "2023-03-26T06:39:28Z",
      "updatedAt": "2023-03-26T06:39:28Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 19,
      "id": "I_kwDOJIBkVc5h8eVK",
      "title": "Mention canonical STHs in acknowledgements or so",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/19",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "@bifurcation reminded me at IETF that this draft shares a lot of properties with the canonical STHs proposal. We should mention it in acknowledgements\u2014apologies, that was not an intentional omission! I suspect it was just so long ago that we just forgot the original inspiration that schemes of that flavor. \ud83d\ude43",
      "createdAt": "2023-03-28T05:46:27Z",
      "updatedAt": "2023-03-28T19:00:52Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "NONE",
          "body": "FWIW, I think the way the CT version of this tended to be labeled was \"STH discipline\", in the sense that STH issuance would be \"disciplined\" to a schedule, so that relying parties would know exactly which tree heads they needed to hold on to.  See, e.g.: https://groups.google.com/a/chromium.org/g/ct-policy/c/dqFtoFBy8YU/m/Xa67FWVCEgAJ",
          "createdAt": "2023-03-28T18:11:31Z",
          "updatedAt": "2023-03-28T18:11:31Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "NONE",
          "body": "BTW, my intent bringing this up in the TLS session wasn't to claim credit, just to make sure that this wasn't going to get tripped up by the same stuff that tripped up STH discipline!",
          "createdAt": "2023-03-28T18:15:33Z",
          "updatedAt": "2023-03-28T18:15:33Z"
        },
        {
          "author": "devonobrien",
          "authorAssociation": "COLLABORATOR",
          "body": "No, thanks so much for bringing it up! STH discipline should definitely be mentioned in the doc as prior art / inspiration. Using MTCs as an optimization with a separate fallback is what allows us to use the concept at the core of STH discipline and extend it without falling into the same catch 22.",
          "createdAt": "2023-03-28T19:00:52Z",
          "updatedAt": "2023-03-28T19:00:52Z"
        }
      ]
    },
    {
      "number": 21,
      "id": "I_kwDOJIBkVc5ihZea",
      "title": "Rename window to validity window?",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/21",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "\"Window\" is a really generic word. And if we do #2, we'll have multiple windows flying around. Maybe we should call it \"validity window\"? It makes it a bit clearer that we're talking about the particular thing.",
      "createdAt": "2023-04-03T23:39:29Z",
      "updatedAt": "2023-04-03T23:39:29Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 22,
      "id": "I_kwDOJIBkVc5iu9nS",
      "title": "Talk about RP <-> TS communication under Privacy Considerations",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/22",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "We do leave the exact RP <-> TS protocol out of scope, so that it can slot into existing RP update protocols, but it's probably worth calling out a couple things here:\r\n\r\n- The RP doesn't contact the TS on each TLS connection, only periodically and out-of-band\r\n- There's no reason for the RP to tell the TS anything about TLS connections. The RP just says \"give me the latest thing\" and the TS passes it along\r\n\r\nSo the only information passed along is \"I exist\", same as any other periodic update protocol.",
      "createdAt": "2023-04-06T00:10:20Z",
      "updatedAt": "2023-04-06T04:59:54Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "It's more than I exist: it's I'm online.",
          "createdAt": "2023-04-06T04:59:54Z",
          "updatedAt": "2023-04-06T04:59:54Z"
        }
      ]
    },
    {
      "number": 23,
      "id": "I_kwDOJIBkVc5iywfV",
      "title": "Evidence",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/23",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "When a CA issues an assertion, it could provide evidence for it. For instance, a (list of) serialised dnssec proof(s) for a ACME dns-01 challenge or CAA record, if that was used. Most validations are http-01 for which no proof can be produced, except perhaps a signature of an independent multi-path DCV service, if that becomes a thing. Is evidence of assertions in scope? I suppose not for an initial version.",
      "createdAt": "2023-04-06T13:53:29Z",
      "updatedAt": "2023-04-06T13:54:47Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 24,
      "id": "I_kwDOJIBkVc5iy14i",
      "title": "TA negotiation useful for draft-kampanakis-tls-scas / draft-jackson-tls-cert-abridge",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/24",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The trust anchor negotiation, and the to-be-written mechanism of provisioning TLS servers with opaque TA->proof blobs, we propose would be useful for [draft-kampanakis-tls-scas](https://datatracker.ietf.org/doc/draft-kampanakis-tls-scas-latest/) as well. We could allocate a `chainless-x509-cert` trust anchor type, whose identifiers would be something akin `ccadb-20230406`, with as proof a X509 certificate whose intermediates are included in ccadb at that date. The ACME client could check CCADB for the intermediates, and if they're included, the chainless trust anchor.",
      "createdAt": "2023-04-06T14:06:28Z",
      "updatedAt": "2023-06-05T12:43:25Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "Same for [draft-jack son-tls-cert-abridge](https://github.com/dennisjackson/draft-jackson-tls-cert-abridge).",
          "createdAt": "2023-06-05T12:43:25Z",
          "updatedAt": "2023-06-05T12:43:25Z"
        }
      ]
    },
    {
      "number": 25,
      "id": "I_kwDOJIBkVc5jI0i6",
      "title": "Subscriber-level delegation",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/25",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "(Filing this mostly to capture vague thoughts. Yet another angle in this vast design space.)\r\n\r\nOver in #10 (CC @bemasc), I asserted that we didn't need delegation in Merkle Tree certificates because they don't make sense when you assume an up-to-date RP anyway.\r\n\r\nTalking with folks at IETF, someone  (I forget who... was it you, @bwesterb?) brought up that a subscriber might want to do delegation. E.g. the CA checks you're authoritative `*.example.com`, but the subscriber wants to mint credentials on demand for `abcdef.example.com`.\r\n\r\nI think the way to think about that apparent contradiction is that _CA-level_ delegation doesn't make sense with up-to-date RPs, but _subscriber-level_ delegation can still make sense. That said, the tradeoffs for such delegation are harsher in a PQ world with large signatures. So I suspect this use case will be much less applicable in the future. But perhaps there are deployments where it's still worth the extra signature.\r\n\r\nSupposing that's the case and we want to support it, one answer is to go back to a generic chaining mechanism like X.509, but another answer is to separate the two, a la TLS delegated credentials. I kinda like the latter, actually. As an RP, we already think the two cases have very different requirements. Existing CA policies often distinguish cross-signs from technically-constrained CAs. If we want to capture that, one model would be basically TLS DCs, where we have a `tls_delegated_credential_signer` (or whatever) SubjectType and some place to inject the DC. Possibly amended to allow refining the name set in the DC, I dunno.",
      "createdAt": "2023-04-11T21:40:46Z",
      "updatedAt": "2023-04-12T08:47:18Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "> I forget who... was it you, @bwesterb?\r\n\r\nIt might've been @galadran? Anyway, I do agree.",
          "createdAt": "2023-04-12T08:47:18Z",
          "updatedAt": "2023-04-12T08:47:18Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "I_kwDOJIBkVc5ljPhu",
      "title": "Bitflips",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/26",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We should spend a few words on what to do with bit flips.",
      "createdAt": "2023-05-10T11:44:26Z",
      "updatedAt": "2023-05-10T12:30:17Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "I do not think we should cover all this in the draft, but it's a good exercise.\r\n\r\n1. **Bitflip in assertion** at CA. Say an assertion is published for `gnogle.com` instead of `google.com`. This should be counted as a misissuance, and detecting these is one of the reasons for CT. I'd say it's out of scope to decide what should happen next: that's a policy matter of the root programs/RPs.\r\n2. **Bitflip when computing authentication path** at CA. The subscriber will get a certificate that simply doesn't validate. The ACME client can check the certificate before installing it. This will be caught early on without lasting impact.\r\n3. **Bitflip when signing a Window** at CA. This one is trickier. On the one hand, when checking the signed window, the TS see that the batch tree heads do not match. They could simply ignore that particular window. However, the situation would be similar to when a CA tries to split the world view. I guess we will need to be tough on this one too. It's not impossible to avoid for the CA: before publishing the signed window, the CA should check whether it verifies to detect any bit flip.\r\n6. **Bitflip when serving assertions** at CA. This is related to the previous. A bit flip might make the CA serve the wrong assertion. I think we can be more lenient here. If the TS fetches the assertions a second time, it'll probably get the correct values and the window signature will validate.\r\n7. **Bitflip when serving a Window** at CA. If the bit flip is in the signature, we can be lenient. It's important that the signed message is explicit: if we would not have included the tree heads in the signed window, then we couldn't be lenient here. If the bit flip is in one of the tree head, we can also be lenient: the signature will not validate and thus we know it's not part of a split world view attack.\r\n\r\nThere must be more cases I'm missing here.",
          "createdAt": "2023-05-10T12:29:49Z",
          "updatedAt": "2023-05-10T12:30:17Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "I_kwDOJIBkVc5nnEh-",
      "title": "Elaborate on CA public key",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/27",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In `-00` we write\r\n\r\n```\r\npublic_key: The public half of a signing keypair. The corresponding private key, private_key, is known only to the CA.\r\n```\r\n\r\nThis needs elaboration. We could pick one post-quantum signature scheme, as we have picked SHA256 as hash. Say Dilithium2. It's not unconceivable that we'll want to migrate to a new signature scheme. Perhaps because Dilithium2's security is weaker than expected, but more likely because a significantly better post-quantum signature scheme has stabilised.\r\n\r\nProofType should afford enough flexibility for this.\r\n\r\nAlternatively, we can simply use a `TLSSubjectInfo`-like structure for the CA public key.\r\n\r\nA different idea, is to use a stateful hash based signature such as LMS or XMSS. There is no need to keep state: instead we can use the `n`th one-time-signature for the `n`th window. Clients can check whether the right OTS is used. Then if the CA accidentally signs and published the same window twice, then the private key is only compromised for that window, which will be ignored anyway by TSs if such a thing happens. With `n=16`, `h=20` and `w=16`, a key pair will last 119 years, signatures will be 880 bytes, verification will take 1,181 SHA2 hashes and keygen 1 billion SHA2 hashes. The upside is that this is definitely post-quantum secure. But this is all rather more complicated to implement than a plain signature, so I suppose we're better of sticking with Dilithium for now and accept we might have to change at some point. (This would complicate signing revocation lists.)\r\n",
      "createdAt": "2023-06-02T14:19:10Z",
      "updatedAt": "2023-06-05T12:45:43Z",
      "closedAt": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "We probably don't need to optimize the signature here too much, compared to more fast-issuance schemes. We effectively amortize everything relating to the CA's key on the CA -> TS -> RP path. Keys and signatures barely even show up on the wire, though yeah we'll certainly need to define it as part of I guess #12.\r\n\r\nThe trick with using the counter in lieu of state is fun. I suppose, yeah, this is a place where stateful hash-based sigs are less of a disaster. But given the signature is not that load-bearing, I think \"don't do anything interesting and pick something default\" is the way to go. :-)",
          "createdAt": "2023-06-02T15:03:25Z",
          "updatedAt": "2023-06-02T15:03:25Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "> signatures barely even show up on the wire\r\n\r\nShouldn't they also be sent to the browser?\r\n\r\n> don't do anything interesting and pick something default\r\n\r\nYeah, let's keep it simple for now.",
          "createdAt": "2023-06-02T15:59:51Z",
          "updatedAt": "2023-06-02T15:59:51Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "> Shouldn't they also be sent to the browser?\r\n\r\nYeah, at least usually. :-) But it also happens in the RP <-> TS flow which is left somewhat unspecified. I expect browsers, for instance, would reuse their update protocols. Right now the text says:\r\n\r\n> The transparency service publishes the mirrored CA state using the same interface as {{publishing}}. The protocol between the relying party and transparency service is out of scope of this document. The relying party MAY use the interface defined here, or an existing application-specific authenticated channel.\r\n>\r\n> As discussed in {{authenticity}}, relying parties MUST ensure that any windows obtained were asserted by the CA. This SHOULD be done by having the transparency service forward the CA's signature, with the relying party verifying it. However, if the transparency service already maintains a trusted, authenticated channel to the relying parties (e.g. a software or root store update channel), relying parties MAY rely on the transparency service to validate the CA windows on their behalf, only sending valid windows over this channel.\r\n\r\nEither way, yeah, we do need to define the structure with the signed window structure because the CA <-> TS flow needs to be defined. (We actually don't _need_ define the public key format because that's never transmitted anywhere. It's part of your application-local root store configuration story. But defining a format for convenience makes sense anyway.)",
          "createdAt": "2023-06-02T17:26:44Z",
          "updatedAt": "2023-06-02T17:26:44Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "I_kwDOJIBkVc5npZ-_",
      "title": "Should the signing payload include 64 spaces in front?",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/30",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Feedback from Ilari Liusvaara on the list:\r\n\r\n> - I think LabeledWindow should add 64 spaces in front, so it\r\n>  reuses the TLS 1.3 signature format.\r\n>\r\n>  This reduces risks of cross-protocol attack if the key gets\r\n>  reused anyway (despite there being MUST NOT requirement).\r\n\r\nI'm slightly torn on this, though I don't feel very strongly either way. (Past Davids have gone both directions on this.)\r\n\r\nOn one hand, it costs very little and reduces cross-protocol attacks with TLS 1.2 if you reuse keys. Even though we explicitly told you not to reuse those keys.\r\n\r\nOn the other hand, it only reduces attacks with TLS 1.2, and this key was already explicitly not meant to be a TLS key. Where do such things end? Should every new protocol forever guard against potential reuse with TLS 1.2, even when it (like this one) was not designed to be used with TLS? Should we guard against reuse with other protocols too? Context string constructions aren't standard (hash-to-curve does a suffix instead of a prefix), so the real defense is key separation. Maybe we should _finally_ just get better at key separation.",
      "createdAt": "2023-06-02T22:39:26Z",
      "updatedAt": "2023-06-05T10:16:05Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it's good practice to add some context, which we already do, so that we can use the Merkle CA's key to sign other things besides the window. This also helps against accidental cross-protocol attacks. (Unfortunately we all haven't agreed on the standard way to do this. It'd be nice if every signature scheme would have a context string as input, but that's a separate discussion.)\r\n\r\nI don't think it's worthwhile to add the 64 spaces in front, if we mandate separate keys. We wouldn't just have to deal with TLS, but every other protocol where the same key can be used as well.",
          "createdAt": "2023-06-05T10:16:05Z",
          "updatedAt": "2023-06-05T10:16:05Z"
        }
      ]
    },
    {
      "number": 31,
      "id": "I_kwDOJIBkVc5npdLL",
      "title": "Canonicalize claim structures further and think about multiplicity",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/31",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Feedback from Ilari Liusvaara on the list:\r\n\r\n>  I don't see rule for how claims are sorted within each type,\r\n>  only how different types are sorted.\r\n\r\nand:\r\n\r\n> - If each claim was in its own Claim, then one could maybe even\r\n>  shorten [the length prefix] to 8 bits. Similarly, one could merge ipv4/ipv6 and\r\n>  dns/dns_wildcard.\r\n>\r\n>  This could also simplify sorting: Sort by type, lexicographic\r\n>  sort by claim contents.\r\n\r\nMoving the multiplicity up a layer avoids every ClaimType defining it itself, and reuses some length prefixes given how the TLS presentation language works, though it means a non-multiplicative Claim would need extra logic to reject duplicates. Is that a problem?\r\n\r\nOne way or another, I am a fan of canonicalizing the order more strongly, just for the sake of having only one way to encode it. Though how we canonicalize may be interesting... if DNS names are pre-sorted in hierarchical order, evaluating name constraints efficiently becomes a lot easier.",
      "createdAt": "2023-06-02T22:56:08Z",
      "updatedAt": "2023-06-02T22:56:08Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 32,
      "id": "I_kwDOJIBkVc5npi7K",
      "title": "Feedback on hash construction",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/32",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [
        "bwesterb"
      ],
      "labels": [],
      "body": "Feedback from Ilari Liusvaara on the list:\r\n\r\n> - The root hash being dependent on issuer and batch number iff there\r\n>  are multiple assertions looks very odd.\r\n>\r\n>  Empty assertion list might be special. But this also happens for\r\n>  one assertion.\r\n\r\nIt is a little odd that HashNode takes all these extra distinguishers, but HashAssertion doesn't. @bwesterb, you suggested doing something like this to align with something that SPHINCS+ was doing, right? Should we have it on both?",
      "createdAt": "2023-06-02T23:29:22Z",
      "updatedAt": "2023-06-02T23:29:22Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 35,
      "id": "I_kwDOJIBkVc5nzu6G",
      "title": "Should claims include ports?",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/35",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "> [[TODO: For now, the claims below just transcribe the X.509 GeneralName structure. Should these be origins instead? For HTTPS, it's a pity to not capture the scheme and port. We do mandate ALPN in {{tls-certificate-type}}, so cross-protocol attacks are mitigated, but it's unfortunate that subscribers cannot properly separate their HTTPS vs FTPS keys, or their port 443 vs port 444 keys. One option here is to have HTTPS claims instead, and then other protocols can have FTPS claims, etc.]]",
      "createdAt": "2023-06-05T11:55:14Z",
      "updatedAt": "2023-06-05T11:55:24Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 36,
      "id": "I_kwDOJIBkVc5nzvXU",
      "title": "Multiple signing keys?",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/36",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "> [[TODO: The signing key case is interesting. A CA could actually maintain a single stream of Merkle Trees, but then sign everything with multiple keys to support rotation. The CA -> Subscriber -> RP flow does not depend on the signature, only the CA -> Transparency Service -> RP flow. The document is not currently arranged to capture this, but it probably should be. We probably need to decouple the signing half and the Merkle Tree half slightly.]]",
      "createdAt": "2023-06-05T11:56:36Z",
      "updatedAt": "2023-06-05T11:56:36Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 37,
      "id": "I_kwDOJIBkVc5nzwlR",
      "title": "Downtime lenience",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/37",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "> [[TODO: If the mirror gets far behind, if the CA just stops publishing for a while, it may suddenly have to catch up on many batches. Should we allow the mirror to catch up to the latest window and skip the intervening batches? The intervening batches are guaranteed to have been expired]] ",
      "createdAt": "2023-06-05T11:58:59Z",
      "updatedAt": "2023-06-05T14:15:27Z",
      "closedAt": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "I suspect the is the same as #2, or at least can be. Unless we want to have both a storage window and allow gaps within the storage window, but that's probably a bit much.\r\n\r\nIf we say the mirrors can't have gaps, then this equivalent to saying that if you fail to update for a whole storage window, you can just start from scratch and only catch up to whatever range you're expected to maintain in the steady state. Basically as if you were starting over as a new mirror.",
          "createdAt": "2023-06-05T14:15:26Z",
          "updatedAt": "2023-06-05T14:15:26Z"
        }
      ]
    },
    {
      "number": 38,
      "id": "I_kwDOJIBkVc5nzyT8",
      "title": "Should TLSSubjectInfo have an extension list?",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/38",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-06-05T12:02:28Z",
      "updatedAt": "2023-06-05T12:02:28Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 39,
      "id": "I_kwDOJIBkVc5nzy8R",
      "title": "Include new post-quantum TLS signature schemes",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/39",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "> [[TODO: If other schemes get defined before this document is done, add them here. After that, it's on the other schemes to do it.]]",
      "createdAt": "2023-06-05T12:03:40Z",
      "updatedAt": "2023-06-05T12:03:40Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 40,
      "id": "I_kwDOJIBkVc5nzz99",
      "title": "[duplicate] Client certificates",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/40",
      "state": "CLOSED",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "> This section defines the `Bikeshed` TLS certificate type, which may be negotiated with the `client_certificate_type`, `server_certificate_type` {{!RFC7250}}, or `cert_type` {{!RFC6091}} extensions. It can only be negotiated with TLS 1.3 or later. Servers MUST NOT negotiate it in TLS 1.2 or below. If the client receives a ServerHello that negotiates it in TLS 1.2 or below, it MUST abort the connection with an `illegal_parameter` alert.\r\n>\r\n> [[TODO: None of these three extensions is quite right for client certificates because the negotiation isn't symmetric. See discussion in {{cert-type-problems}}. We may need to define a third one.]]\r\n",
      "createdAt": "2023-06-05T12:05:39Z",
      "updatedAt": "2023-06-05T12:48:04Z",
      "closedAt": "2023-06-05T12:47:15Z",
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "Duplicate of #18 ",
          "createdAt": "2023-06-05T12:47:15Z",
          "updatedAt": "2023-06-05T12:47:15Z"
        }
      ]
    },
    {
      "number": 41,
      "id": "I_kwDOJIBkVc5nz1He",
      "title": "Revocation",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/41",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "> [[TODO: Is it worth defining an API for Merkle Tree CAs to publish a revocation list? That would allow automatically populating CRLite and CRLSets. Maybe that's a separate document.]] ",
      "createdAt": "2023-06-05T12:08:06Z",
      "updatedAt": "2023-06-05T12:08:06Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 42,
      "id": "I_kwDOJIBkVc5nz1P_",
      "title": "IANA considerations",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/42",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-06-05T12:08:24Z",
      "updatedAt": "2023-06-05T12:08:24Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 45,
      "id": "I_kwDOJIBkVc5n_bNf",
      "title": "Is it worthwhile to avoid requiring collision resistance from our hash?",
      "url": "https://github.com/davidben/merkle-tree-certs/issues/45",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "There has always been a significant gap between (chosen prefix) collision and (second) preimage attacks on hashes. It would be neat if we do not have to assume (chosen prefix) collision resistance of our hash. I'd say it's a nice-to-have, but not a must.\r\n\r\nIncomplete list of changes:\r\n\r\n1. For each batch, the CA generates a 16 byte randomizer `R` which is used as input to `Hash`{`Assertion`,`Node`,`Empty`}. We can either put the randomizer in the proof (in the bikeshed certificate) or pass it along in the signed window.",
      "createdAt": "2023-06-06T22:04:02Z",
      "updatedAt": "2023-06-07T08:48:30Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 4,
      "id": "PR_kwDOJIBkVc5MV2RT",
      "title": "Clarify time computations are done in POSIX time",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/4",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Specifically, that they are done without leap seconds. This ensures the issuance and expiration times of all batches are consistently computed.\r\n\r\nI've also moved 'Terminology and Roles' to 'Conventions and Definitions' because it probably should go there.\r\n\r\n(This is the same as what would happen if you implemented it naively, but we need to be precise in a spec.)\r\n\r\nFixes #1",
      "createdAt": "2023-03-17T22:10:07Z",
      "updatedAt": "2023-03-24T12:31:07Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "8fc2899a8369dd2ef166baee0dc1245488b7279f",
      "headRepository": "davidben/merkle-tree-certs",
      "headRefName": "time",
      "headRefOid": "6396096589efc539d68dd403d81552959e52665e",
      "closedAt": "2023-03-18T01:18:43Z",
      "mergedAt": "2023-03-18T01:18:43Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "a5fbe420d77be2415b3c0bc7a1d6ce915bfb452d"
      },
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "@bob-beck since we've been talking about time a lot lately.",
          "createdAt": "2023-03-17T22:10:27Z",
          "updatedAt": "2023-03-17T22:10:27Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc5QRlto",
          "commit": {
            "abbreviatedOid": "6396096"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-17T22:15:40Z",
          "updatedAt": "2023-03-17T22:15:40Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJIBkVc5QRlx8",
          "commit": {
            "abbreviatedOid": "6396096"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-17T22:16:10Z",
          "updatedAt": "2023-03-17T22:16:11Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Positive integers I presume.",
              "createdAt": "2023-03-17T22:16:10Z",
              "updatedAt": "2023-03-17T22:16:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5QRl18",
          "commit": {
            "abbreviatedOid": "6396096"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-17T22:16:19Z",
          "updatedAt": "2023-03-17T22:16:19Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Do you allow negative integers?",
              "createdAt": "2023-03-17T22:16:19Z",
              "updatedAt": "2023-03-17T22:16:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5QRmD3",
          "commit": {
            "abbreviatedOid": "6396096"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-17T22:17:56Z",
          "updatedAt": "2023-03-17T22:17:57Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Hmm, not sure. We don't currently use them anywhere, but it's perfectly defined to add integers in integer space. Dunno, do you have a preference?",
              "createdAt": "2023-03-17T22:17:56Z",
              "updatedAt": "2023-03-17T22:17:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5QRmEO",
          "commit": {
            "abbreviatedOid": "6396096"
          },
          "author": "bob-beck",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-17T22:17:58Z",
          "updatedAt": "2023-03-17T22:17:59Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Should you move this down with the other definitions (issuance time? etc)?",
              "createdAt": "2023-03-17T22:17:59Z",
              "updatedAt": "2023-03-17T22:17:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5QRmGv",
          "commit": {
            "abbreviatedOid": "6396096"
          },
          "author": "bob-beck",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-17T22:18:15Z",
          "updatedAt": "2023-03-17T22:18:15Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJIBkVc5QRmV7",
          "commit": {
            "abbreviatedOid": "6396096"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-17T22:19:59Z",
          "updatedAt": "2023-03-17T22:19:59Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "What, you don't want to get a time machine and start a CA in the 1800s? :-)\r\n\r\nI suspect this should go the same way as the question below. If we want to be able to say \"10 seconds before some time\", we should probably allow negative numbers just so the operation is defined everywhere. If not, probably doesn't matter either way.",
              "createdAt": "2023-03-17T22:19:59Z",
              "updatedAt": "2023-03-17T22:19:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5QRmbw",
          "commit": {
            "abbreviatedOid": "6396096"
          },
          "author": "bob-beck",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-17T22:20:36Z",
          "updatedAt": "2023-03-17T22:20:36Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "remember that time_t is signed. ",
              "createdAt": "2023-03-17T22:20:36Z",
              "updatedAt": "2023-03-17T22:20:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5QR2x6",
          "commit": {
            "abbreviatedOid": "6396096"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-18T01:12:44Z",
          "updatedAt": "2023-03-18T01:12:44Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Although this spec talks in terms of mathematical integers anyway. But yeah it seems signed is easier here.",
              "createdAt": "2023-03-18T01:12:44Z",
              "updatedAt": "2023-03-18T01:12:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5QR2yx",
          "commit": {
            "abbreviatedOid": "6396096"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-18T01:13:20Z",
          "updatedAt": "2023-03-18T01:13:20Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "(Resolving to negatives allowed per other thread. It'll never actually happen but keeps the operations complete.)",
              "createdAt": "2023-03-18T01:13:20Z",
              "updatedAt": "2023-03-18T01:13:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5QR2-R",
          "commit": {
            "abbreviatedOid": "6396096"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-18T01:18:29Z",
          "updatedAt": "2023-03-18T01:18:29Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "That's actually the parameters to a CA. The terminology bit is a little awkward... right now, the terminology section just defines enough terms to talk about the overview and the rest is inline. It's... probably not quite the right model. I didn't want to drop a wall of terms without how they go together, but everything inline was differently awkward so... now we have a bit of both. :-/\r\n\r\nThinking I'll leave it as-is for now, since I imagine the organization will need to change more drastically as the document evolves anyway.",
              "createdAt": "2023-03-18T01:18:29Z",
              "updatedAt": "2023-03-18T01:18:29Z"
            }
          ]
        }
      ]
    },
    {
      "number": 14,
      "id": "PR_kwDOJIBkVc5MyN10",
      "title": "Reword the introduction slightly",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/14",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "That last bullet doesn't really fit in the list.",
      "createdAt": "2023-03-23T23:04:45Z",
      "updatedAt": "2023-03-24T12:30:53Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "a5fbe420d77be2415b3c0bc7a1d6ce915bfb452d",
      "headRepository": "davidben/merkle-tree-certs",
      "headRefName": "unindent",
      "headRefOid": "7d7de6d68476a3e700d6d18dca415a32bffa43d4",
      "closedAt": "2023-03-24T12:30:46Z",
      "mergedAt": "2023-03-24T12:30:46Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "932f949c3bd7d2201b8918e39a0f210e520b560d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc5Q2lzQ",
          "commit": {
            "abbreviatedOid": "7d7de6d"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-24T11:10:40Z",
          "updatedAt": "2023-03-24T11:10:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 20,
      "id": "PR_kwDOJIBkVc5NiP4W",
      "title": "Clarify that we use just a single CertificateEntry",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/20",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #11",
      "createdAt": "2023-04-03T23:37:52Z",
      "updatedAt": "2023-04-04T13:30:58Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "932f949c3bd7d2201b8918e39a0f210e520b560d",
      "headRepository": "davidben/merkle-tree-certs",
      "headRefName": "single-cert-entry",
      "headRefOid": "9eb61e9788432b475d3523d86b1b0ebfd3e9fc9b",
      "closedAt": "2023-04-04T13:30:54Z",
      "mergedAt": "2023-04-04T13:30:54Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "94daadcb1645ad814ef3dea344a015886bbec655"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc5Rtpvo",
          "commit": {
            "abbreviatedOid": "9eb61e9"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-04T12:58:26Z",
          "updatedAt": "2023-04-04T12:58:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 28,
      "id": "PR_kwDOJIBkVc5SB9wy",
      "title": "Shorten some length prefixes",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/28",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Feedback from Ilari Liusvaara on the list. I picked the lengths mostly arbitrarily. This shaves a few bytes, though it does introduce some length limits over X.509 in TLS today. (TLS uses 2^24-1 for the overall certificate structure. Within a certificate, DER gives variable-length lengths.)",
      "createdAt": "2023-06-02T19:42:24Z",
      "updatedAt": "2023-06-02T19:43:21Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "94daadcb1645ad814ef3dea344a015886bbec655",
      "headRepository": "davidben/merkle-tree-certs",
      "headRefName": "trim-lengths",
      "headRefOid": "70e7a9955e1af5dafc850a36c15b15a19e3dbd6e",
      "closedAt": "2023-06-02T19:43:16Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Actually, let me close this and do a larger PR with the rest of the comments too. I missed there were a few more.",
          "createdAt": "2023-06-02T19:43:16Z",
          "updatedAt": "2023-06-02T19:43:16Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 29,
      "id": "PR_kwDOJIBkVc5SCkhp",
      "title": "Shorten some length prefixes",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/29",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Feedback from Ilari Liusvaara on the list. I picked the lengths mostly arbitrarily. This shaves a few bytes, though it does introduce some length limits over X.509 in TLS today. (TLS uses 2^24-1 for the overall certificate structure. Within a certificate, DER gives variable-length lengths.)",
      "createdAt": "2023-06-02T22:33:29Z",
      "updatedAt": "2023-06-05T21:45:48Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "25f9893e67de075d9bd65725bd2df8bbf343f08c",
      "headRepository": "davidben/merkle-tree-certs",
      "headRefName": "trim-lengths-2",
      "headRefOid": "89db77c25e7892fcd02dab8725ec6011f27d2354",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "One thing to ponder: if a ProofType combines X.509-style delegation (so multiple signatures) with one of the really, really large signature schemes, will 64KiB be too tight? I can't imagine actually being happy going that high, but maybe someone wants that? @bwesterb, you probably are better to judge that than me as I've been paying less attention to the sizes available.",
          "createdAt": "2023-06-05T19:29:04Z",
          "updatedAt": "2023-06-05T19:29:04Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "> I can't imagine actually being happy going that high\r\n\r\nThere are signature schemes with really big public keys, but you wouldn't use those unless you don't have to send the public keys all the time.\r\n\r\nAt 128 bits security, none of the reasonable schemes will hit the limit. Even SPHINCS+ will not. It has two variants, one optimised for size (~8kB sig, 32B pk) and one for signing speed (~17kB sig, 32B pk).",
          "createdAt": "2023-06-05T21:27:16Z",
          "updatedAt": "2023-06-05T21:27:16Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc5W8QN9",
          "commit": {
            "abbreviatedOid": "32fd2da"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-03T00:10:54Z",
          "updatedAt": "2023-06-03T00:10:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 33,
      "id": "PR_kwDOJIBkVc5SLddO",
      "title": "Properly separate hashes in Merkle tree",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/33",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #32\r\n\r\nAlso adds change log.",
      "createdAt": "2023-06-05T10:37:29Z",
      "updatedAt": "2023-06-05T10:37:29Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "94daadcb1645ad814ef3dea344a015886bbec655",
      "headRepository": "bwesterb/merkle-tree-certs",
      "headRefName": "issue-32",
      "headRefOid": "6e56087e8d594e9804c59606bbd883ac187ef115",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 34,
      "id": "PR_kwDOJIBkVc5SL3o_",
      "title": "Only include hash of subject_info in Assertion",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/34",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Move subject_info itself to BikeshedCertificate.\r\n\r\nThis reduces the amount of data that needs to be served by CAs a lot, expecting large post-quantum public keys.\r\n\r\nOne downside is that it complicates the verification a bit: a verifier should not forget to check whether subject_info_hash matches subject_info.\r\n\r\nAlso, to keep verification simpler, we make subject_info less flexible: always expecting a hash in an assertion. We could go for a mix of hashed and unhashed subject info in the assertion, but I do not see an application yet.\r\n\r\nSee #6 ",
      "createdAt": "2023-06-05T11:48:09Z",
      "updatedAt": "2023-06-06T11:30:48Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "94daadcb1645ad814ef3dea344a015886bbec655",
      "headRepository": "bwesterb/merkle-tree-certs",
      "headRefName": "issue-6",
      "headRefOid": "e86df57f07bf71e896ce78e36a1b668e79263b12",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc5XMJDk",
          "commit": {
            "abbreviatedOid": "e86df57"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-05T15:18:03Z",
          "updatedAt": "2023-06-05T15:18:03Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "This is a little interesting with the current extensibility model (not to say that extensibility model is the right one!) because `hash` doesn't exist at this layer. I.e. imagine if we defined both `merkle_tree_sha256` and `merkle_tree_sha384`. Or `some_proof_type_without_hashes_at_all`. How would you know which hash to use? This gets extra fun when you imagine a subscriber that doesn't know about the proof type.\r\n\r\nI'd been envisioning `Assertion` becomes the thing that the subscriber understands and cares about, and the proof is the CA <-> RP communication that they're just proxying alone. You could imagine this starting life all the way at the issuance protocol too, all the way up to the CSR equivalent. (Today, CSRs, ACME newOrder requests, and certificates all carry this information in completely different forms.) The lifecycle could then be:\r\n\r\n1. The subscriber is configured to speak TLS in a certain way. It assembles the corresponding `Assertion` structure.\r\n2. Subscriber passes this `Assertion` to the CA. The CA checks this...\r\n    1. If the subscriber requests any claims it doesn't understand, return an error\r\n    2. For each claim, perform the appropriate validation.\r\n    3. (handwaiving, and I'm sure doesn't actually work for lots of reasons) Bonus points if that validation is tightly bound to the `Assertion` structure, which the subscriber can do easily because they assembled it. E.g. you could a `validation` proof type, where the proof is empty and the trust anchor is hash(assertion) (just for negotiation purposes). The subscriber's server's ability and willingness to make a TLS connection with certificate is then analogous to the tls-alpn-01.\r\n3. CA hands back a bunch of `BikeshedCertificates`. They all have the requested `Assertion` (subscriber checks this and raises an alert otherwise) but different proofs (subscriber doesn't care about the contents of this).\r\n\r\nObviously we don't actually need this flow, and I doubt it's _actually_ worth recasting all of ACME around this structure, but being able to do something like this was part of the motivation around the current structure.",
              "createdAt": "2023-06-05T15:18:03Z",
              "updatedAt": "2023-06-05T15:18:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5XMRe5",
          "commit": {
            "abbreviatedOid": "e86df57"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-05T15:32:20Z",
          "updatedAt": "2023-06-05T15:32:21Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I suppose, under this model (if we want to keep it!), we'd have the `Assertion` struct which is the general, unhashed one. But then the tree is computed over:\r\n\r\n```\r\nstruct {\r\n    SubjectType subject_type;\r\n    HashValueSHA256 subject_type_hash;\r\n    Claim claims<0..2^24-1>;\r\n} MerkleTreeAssertionSHA256;\r\n```",
              "createdAt": "2023-06-05T15:32:20Z",
              "updatedAt": "2023-06-05T15:32:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5XPMqO",
          "commit": {
            "abbreviatedOid": "e86df57"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-05T22:13:57Z",
          "updatedAt": "2023-06-05T22:13:57Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I like pulling out `Assertion` like this in the ACME flow.\r\n\r\n(Minor point: if I understand correctly, if we'd want to leave out the hash in the BikeshedCertificate, we'd have three different assertion structs: the one with the public key for the \"CSR\"; the one with the hash for the tree and CA to publish; and the one without the hash for the BikeshedCertificate.)\r\n\r\nOriginally I thought we could group almost everything we propose under MTC, except perhaps for the negotiation mechanism itself. But now it came into focus for me that you intend most of the structures to be reused by instances different from MTC. Perhaps we should name this more general system, and move the hash into it. Perhaps: `web-sha256` and have MTC be a certificate type of it `web-sha256/mtc`.",
              "createdAt": "2023-06-05T22:13:57Z",
              "updatedAt": "2023-06-05T22:13:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5XPeao",
          "commit": {
            "abbreviatedOid": "e86df57"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-05T22:46:20Z",
          "updatedAt": "2023-06-05T22:46:21Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Does the CSR one need the hash? I figured the hash would just be private to MTCs.",
              "createdAt": "2023-06-05T22:46:20Z",
              "updatedAt": "2023-06-05T22:46:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5XPfbb",
          "commit": {
            "abbreviatedOid": "e86df57"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-05T22:48:28Z",
          "updatedAt": "2023-06-05T22:48:29Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "CSR would need the full public key for proof-of-possession.",
              "createdAt": "2023-06-05T22:48:28Z",
              "updatedAt": "2023-06-05T22:48:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5XPf1F",
          "commit": {
            "abbreviatedOid": "e86df57"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-05T22:49:15Z",
          "updatedAt": "2023-06-05T22:49:15Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "(It's a separate question whether proof-of-possession is actually required. I'm not sure either way.)",
              "createdAt": "2023-06-05T22:49:15Z",
              "updatedAt": "2023-06-05T22:49:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5XPh9z",
          "commit": {
            "abbreviatedOid": "e86df57"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-05T22:54:16Z",
          "updatedAt": "2023-06-05T22:54:16Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Oh sure I meant that they would have the unhashed version. I.e. generic is unhashed and both CSRs and certs use unhashed. Hashed only shows up as an implementation detail of building the tree.",
              "createdAt": "2023-06-05T22:54:16Z",
              "updatedAt": "2023-06-05T22:54:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5XPjE_",
          "commit": {
            "abbreviatedOid": "e86df57"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-05T22:56:23Z",
          "updatedAt": "2023-06-05T22:56:23Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "> Hashed only shows up as an implementation detail of building the tree.\r\n\r\nAnd it's what the MTC CAs serve. We don't want them to have to serve all (perhaps big) public keys.",
              "createdAt": "2023-06-05T22:56:23Z",
              "updatedAt": "2023-06-06T11:30:48Z"
            }
          ]
        }
      ]
    },
    {
      "number": 43,
      "id": "PR_kwDOJIBkVc5SMAWu",
      "title": "Miscellaneous",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/43",
      "state": "MERGED",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "1. Add Github issue numbers to TODOs.\r\n2. Correct my initials",
      "createdAt": "2023-06-05T12:10:19Z",
      "updatedAt": "2023-06-05T20:50:50Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "94daadcb1645ad814ef3dea344a015886bbec655",
      "headRepository": "bwesterb/merkle-tree-certs",
      "headRefName": "misc",
      "headRefOid": "0b9b7549827b766287be621c546178493709d9df",
      "closedAt": "2023-06-05T17:28:31Z",
      "mergedAt": "2023-06-05T17:28:31Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "25f9893e67de075d9bd65725bd2df8bbf343f08c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc5XNEr3",
          "commit": {
            "abbreviatedOid": "0b9b754"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-05T17:28:08Z",
          "updatedAt": "2023-06-05T17:28:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 44,
      "id": "PR_kwDOJIBkVc5SMG8N",
      "title": "Rename window to validity window",
      "url": "https://github.com/davidben/merkle-tree-certs/pull/44",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See #21.\r\n\r\nI like plain *window* a bit better, but this is more explicit.\r\n\r\n- [ ] Squash before merging.",
      "createdAt": "2023-06-05T12:29:50Z",
      "updatedAt": "2023-06-05T21:44:22Z",
      "baseRepository": "davidben/merkle-tree-certs",
      "baseRefName": "main",
      "baseRefOid": "25f9893e67de075d9bd65725bd2df8bbf343f08c",
      "headRepository": "bwesterb/merkle-tree-certs",
      "headRefName": "issue-21",
      "headRefOid": "a2ddde4286eb92710c1fea8387b9ea7e90629809",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJIBkVc5XNFKj",
          "commit": {
            "abbreviatedOid": "5b8f607"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-05T17:29:28Z",
          "updatedAt": "2023-06-05T17:44:03Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "```suggestion\r\n2. The CA collects certificate requests into a batch (see {{parameters}}) and builds the Merkle Tree and computes the tree head (see {{building-tree}}). It then signs the validity window ending at this tree head (see {{signing}}) and publishes (see {{publishing}}) the result.\r\n```",
              "createdAt": "2023-06-05T17:29:28Z",
              "updatedAt": "2023-06-05T17:44:03Z"
            },
            {
              "originalPosition": 26,
              "body": "\"validity window state\" reads funny. Since this part is informal anyway, perhaps just...\r\n\r\n```suggestion\r\n6. In an application protocol such as TLS, the relying party communicates its currently saved validity window to the subscriber.\r\n```\r\n\r\nAnd then 5 above maybe should say:\r\n\r\n> 5. The relying party periodically fetches and saves the latest validity window from the transparency service. This validity window will contain the new tree head.\r\n",
              "createdAt": "2023-06-05T17:31:19Z",
              "updatedAt": "2023-06-05T17:44:03Z"
            },
            {
              "originalPosition": 96,
              "body": "Guessing this was to line up with a block size?",
              "createdAt": "2023-06-05T17:34:47Z",
              "updatedAt": "2023-06-05T17:44:03Z"
            },
            {
              "originalPosition": 56,
              "body": "\"validity window signature\" is a bit hard for me to parse. Perhaps:\r\n\r\n```suggestion\r\n* A signature over the corresponding validity window, described in {{signing}}.\r\n```\r\n\r\nEdit: Oh, but I see \"validity window signature\" shows up in two other places in the document. We'd need to fix those too. I mean, we could just call it the \"batch's signature\", which is true. It is the signature corresponding to the batch, we just incorporate the previous batches into that signature.\r\n\r\nDunno. WDYT?",
              "createdAt": "2023-06-05T17:36:12Z",
              "updatedAt": "2023-06-05T17:44:04Z"
            },
            {
              "originalPosition": 177,
              "body": "I wonder if this could just be more efficiently written as:\r\n\r\n```suggestion\r\n* All tree hashes sent to relying parties MUST be reflected in the mirrored CA state.\r\n```",
              "createdAt": "2023-06-05T17:40:39Z",
              "updatedAt": "2023-06-05T17:44:04Z"
            },
            {
              "originalPosition": 182,
              "body": "This might be a little easier to parse:\r\n\r\n```suggestion\r\nAs discussed in {{authenticity}}, relying parties MUST ensure that any validity windows obtained were asserted by the CA. This SHOULD be done by having the transparency service forward the CA's signature, with the relying party verifying it. However, if the transparency service already maintains a trusted, authenticated channel to the relying parties (e.g. a software or root store update channel), relying parties MAY rely on the transparency service to validate the signature on their behalf, rather than sending it over this channel.\r\n```",
              "createdAt": "2023-06-05T17:42:32Z",
              "updatedAt": "2023-06-05T17:44:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5XO6kM",
          "commit": {
            "abbreviatedOid": "5b8f607"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-05T21:39:35Z",
          "updatedAt": "2023-06-05T21:39:35Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "Yeah, it fits nicely, but would be happy with 16 byte label too.",
              "createdAt": "2023-06-05T21:39:35Z",
              "updatedAt": "2023-06-05T21:39:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJIBkVc5XO7o-",
          "commit": {
            "abbreviatedOid": "5b8f607"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-05T21:41:47Z",
          "updatedAt": "2023-06-05T21:41:47Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "I like window signature better. We're not going to sign other windows, are we? So perhaps just window signature?",
              "createdAt": "2023-06-05T21:41:47Z",
              "updatedAt": "2023-06-05T21:41:47Z"
            }
          ]
        }
      ]
    }
  ]
}